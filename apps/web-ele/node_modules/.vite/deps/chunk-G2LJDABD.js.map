{
  "version": 3,
  "sources": ["../../../../../node_modules/.pnpm/element-plus@2.9.9_vue@3.5.13_typescript@5.8.3_/packages/hooks/use-z-index/index.ts", "../../../../../node_modules/.pnpm/element-plus@2.9.9_vue@3.5.13_typescript@5.8.3_/packages/hooks/use-empty-values/index.ts"],
  "sourcesContent": ["import { computed, getCurrentInstance, inject, ref, unref } from 'vue'\nimport { debugWarn, isClient, isNumber } from '@element-plus/utils'\n\nimport type { InjectionKey, Ref } from 'vue'\n\nexport interface ElZIndexInjectionContext {\n  current: number\n}\n\nconst initial: ElZIndexInjectionContext = {\n  current: 0,\n}\n\nconst zIndex = ref(0)\n\nexport const defaultInitialZIndex = 2000\n\n// For SSR\nexport const ZINDEX_INJECTION_KEY: InjectionKey<ElZIndexInjectionContext> =\n  Symbol('elZIndexContextKey')\n\nexport const zIndexContextKey: InjectionKey<Ref<number | undefined>> =\n  Symbol('zIndexContextKey')\n\nexport const useZIndex = (zIndexOverrides?: Ref<number>) => {\n  const increasingInjection = getCurrentInstance()\n    ? inject(ZINDEX_INJECTION_KEY, initial)\n    : initial\n\n  const zIndexInjection =\n    zIndexOverrides ||\n    (getCurrentInstance() ? inject(zIndexContextKey, undefined) : undefined)\n\n  const initialZIndex = computed(() => {\n    const zIndexFromInjection = unref(zIndexInjection)\n    return isNumber(zIndexFromInjection)\n      ? zIndexFromInjection\n      : defaultInitialZIndex\n  })\n\n  const currentZIndex = computed(() => initialZIndex.value + zIndex.value)\n\n  const nextZIndex = () => {\n    increasingInjection.current++\n    zIndex.value = increasingInjection.current\n    return currentZIndex.value\n  }\n\n  if (!isClient && !inject(ZINDEX_INJECTION_KEY)) {\n    debugWarn(\n      'ZIndexInjection',\n      `Looks like you are using server rendering, you must provide a z-index provider to ensure the hydration process to be succeed\nusage: app.provide(ZINDEX_INJECTION_KEY, { current: 0 })`\n    )\n  }\n\n  return {\n    initialZIndex,\n    currentZIndex,\n    nextZIndex,\n  }\n}\n\nexport type UseZIndexReturn = ReturnType<typeof useZIndex>\n", "import { computed, getCurrentInstance, inject, ref } from 'vue'\nimport { buildProps, debugWarn, isFunction } from '@element-plus/utils'\n\nimport type { ExtractPropTypes, InjectionKey, Ref } from 'vue'\n\ntype EmptyValuesContext = ExtractPropTypes<typeof useEmptyValuesProps>\n\nexport const emptyValuesContextKey: InjectionKey<Ref<EmptyValuesContext>> =\n  Symbol('emptyValuesContextKey')\nexport const SCOPE = 'use-empty-values'\nexport const DEFAULT_EMPTY_VALUES = ['', undefined, null]\nexport const DEFAULT_VALUE_ON_CLEAR = undefined\n\nexport const useEmptyValuesProps = buildProps({\n  /**\n   * @description empty values supported by the component\n   */\n  emptyValues: Array,\n  /**\n   * @description return value when cleared, if you want to set `undefined`, use `() => undefined`\n   */\n  valueOnClear: {\n    type: [String, Number, Boolean, Function],\n    default: undefined,\n    validator: (val: any) => (isFunction(val) ? !val() : !val),\n  },\n} as const)\n\nexport const useEmptyValues = (\n  props: EmptyValuesContext,\n  defaultValue?: null | undefined\n) => {\n  const config = getCurrentInstance()\n    ? inject(emptyValuesContextKey, ref<EmptyValuesContext>({}))\n    : ref<EmptyValuesContext>({})\n\n  const emptyValues = computed(\n    () => props.emptyValues || config.value.emptyValues || DEFAULT_EMPTY_VALUES\n  )\n\n  const valueOnClear = computed(() => {\n    // function is used for undefined cause undefined can't be a value of prop\n    if (isFunction(props.valueOnClear)) {\n      return props.valueOnClear()\n    } else if (props.valueOnClear !== undefined) {\n      return props.valueOnClear\n    } else if (isFunction(config.value.valueOnClear)) {\n      return config.value.valueOnClear()\n    } else if (config.value.valueOnClear !== undefined) {\n      return config.value.valueOnClear\n    }\n    return defaultValue !== undefined ? defaultValue : DEFAULT_VALUE_ON_CLEAR\n  })\n\n  const isEmptyValue = (value: any) => {\n    return emptyValues.value.includes(value)\n  }\n\n  if (!emptyValues.value.includes(valueOnClear.value)) {\n    debugWarn(SCOPE, 'value-on-clear should be a value of empty-values')\n  }\n\n  return {\n    emptyValues,\n    valueOnClear,\n    isEmptyValue,\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAM,UAAU;EACd,SAAS;AACX;AACA,IAAM,SAAS,IAAI,CAAC;AACR,IAAC,uBAAuB;AACxB,IAAC,uBAAuB,OAAO,oBAAoB;AACnD,IAAC,mBAAmB,OAAO,kBAAkB;AAC7C,IAAC,YAAY,CAAC,oBAAoB;AAC5C,QAAM,sBAAsB,mBAAkB,IAAK,OAAO,sBAAsB,OAAO,IAAI;AAC3F,QAAM,kBAAkB,oBAAoB,mBAAkB,IAAK,OAAO,kBAAkB,MAAM,IAAI;AACtG,QAAM,gBAAgB,SAAS,MAAM;AACnC,UAAM,sBAAsB,MAAM,eAAe;AACjD,WAAO,SAAS,mBAAmB,IAAI,sBAAsB;EACjE,CAAG;AACD,QAAM,gBAAgB,SAAS,MAAM,cAAc,QAAQ,OAAO,KAAK;AACvE,QAAM,aAAa,MAAM;AACvB,wBAAoB;AACpB,WAAO,QAAQ,oBAAoB;AACnC,WAAO,cAAc;EACzB;AACE,MAAI,CAAC,YAAY,CAAC,OAAO,oBAAoB,GAAG;AAC9C,cAAU,mBAAmB;yDACwB;EACzD;AACE,SAAO;IACL;IACA;IACA;EACJ;AACA;A;;;AC7BY,IAAC,wBAAwB,OAAO,uBAAuB;AACvD,IAAC,QAAQ;AACT,IAAC,uBAAuB,CAAC,IAAI,QAAQ,IAAI;AACzC,IAAC,yBAAyB;AAC1B,IAAC,sBAAsB,WAAW;EAC5C,aAAa;EACb,cAAc;IACZ,MAAM,CAAC,QAAQ,QAAQ,SAAS,QAAQ;IACxC,SAAS;IACT,WAAW,CAAC,QAAQ,WAAW,GAAG,IAAI,CAAC,IAAG,IAAK,CAAC;EACpD;AACA,CAAC;AACW,IAAC,iBAAiB,CAAC,OAAO,iBAAiB;AACrD,QAAM,SAAS,mBAAkB,IAAK,OAAO,uBAAuB,IAAI,CAAA,CAAE,CAAC,IAAI,IAAI,CAAA,CAAE;AACrF,QAAM,cAAc,SAAS,MAAM,MAAM,eAAe,OAAO,MAAM,eAAe,oBAAoB;AACxG,QAAM,eAAe,SAAS,MAAM;AAClC,QAAI,WAAW,MAAM,YAAY,GAAG;AAClC,aAAO,MAAM,aAAY;IAC/B,WAAe,MAAM,iBAAiB,QAAQ;AACxC,aAAO,MAAM;IACnB,WAAe,WAAW,OAAO,MAAM,YAAY,GAAG;AAChD,aAAO,OAAO,MAAM,aAAY;IACtC,WAAe,OAAO,MAAM,iBAAiB,QAAQ;AAC/C,aAAO,OAAO,MAAM;IAC1B;AACI,WAAO,iBAAiB,SAAS,eAAe;EACpD,CAAG;AACD,QAAM,eAAe,CAAC,UAAU;AAC9B,WAAO,YAAY,MAAM,SAAS,KAAK;EAC3C;AACE,MAAI,CAAC,YAAY,MAAM,SAAS,aAAa,KAAK,GAAG;AACnD,cAAU,OAAO,kDAAkD;EACvE;AACE,SAAO;IACL;IACA;IACA;EACJ;AACA;",
  "names": []
}
